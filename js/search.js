// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Authors",
      "url": "/spire/extra_md/authors.html",
      "content": "Authors A successful open-source project relies upon the community to: discuss requirements and possible designs submit code and tests identify and fix bugs create documentation and examples provide feedback support each other This file lists the people whose contributions have made Spire possible. Ben Barnard: documentation fixes Luc J. Bourhis: author of spire.matrix.* Brad Buchsbaum: bug fixes Eugene Burmako: macros, tons of macro support, build contributions Franco Callari: author of spire.math.Jet Olivier Chafik: cfor macro assistance, bug fixes Adelbert Chang: bug reports Eric Christiansen: bug fixes Jean-Remi Desjardins: documentation fixes Suminda Dharmasena: feature requests and bug reports Rob Emanuele: cfor macro bug reports and fixes, benchmarking Siddhartha Gadgil: bug fixes ghostroad: extensive fixes and added documentation to spire.math.Sorting Markus Hauck: documentation fixes Christopher Hodapp: documentation fixes Lars Hupel: core maintainer, law-checking, release support Ben Hutchison: bug reports and design suggestions Luka Jacobowitz: bug fixes Stephen Lazaro: definition of left and right modules Sung-Ho Lee: bug fixes Kamushin: bug fixes Rüdiger Klaehn: core maintainer, rational improvements, testing Rex Kerr: author of many of the PRNGs found in spire.random Grzegorz Kossakowski: much build support, 2.11 upgrading help, bug reports Jakub Kozłowski: documentation fixes Christian Krause: suggestions around stats methods and spire.random. Dušan Kysel: author of Ziggurat, MersenneTwister and WELL PRNGs Josh Marcus: bug reports and benchmarking Brian McKenna: documentation fixes Kevin Meredith: bug fixes, bug reports, and documentation Simon Ochsenreither: bug reports and build contributions Erik Osheim: core maintainer Vladimir Pavkin: fixes to Interval Adam Pingel: bug fixes André L. F. Pinto: improve build configuration Pablo Pita: documentation r0estir0bbe: bug fixes Alexey Romanov: add PCG random number generator Denis Rosset: core maintainer, interval fixes, partial algebras/orders, etc Lukas Rytz: bug fixes Kazuhiro Sera: build updates and support Jack Sullivan: literal conversion macros Tom Switzer: core maintainer Flaviu Tamas: byte-manipulation and bounds-checking macros James Thompson: author of spire.math.Polynomial Titorenko: bug fixes Vlad Ureche: specialization support, work on spire-miniboxing Volth: bug reports and feedback around intervals William Waites: bug fixes Jed Wesley-Smith: bug fixes Ryan Williams: bug fixes Kenji Yoshida: bug fixes Benito van der Zander: many bug reports, and much good testing Alec Zorab: clean up and tests We’ve tried to include everyone, but if you’ve made a contribution to Spire and are not listed, please feel free to open an issue or pull request with your name and contribution. Thank you!"
    } ,    
    {
      "title": "Changes",
      "url": "/spire/extra_md/changes.html",
      "content": "Release notes are now published on GitHub. Version 0.16.1-SNAPSHOT (not released) Disabled benchmarked depending on Caliper; waiting for migration to a modern benchmarking framework Fixes to polynomials Revised integer Euclidean division semantics: remainder is usually nonnegative (and that’s important to define polynomial rings over integers) The ranges provided to sorting algorithms are now consistent across methods, see https://github.com/non/spire/pull/738 : “All these strategies operate in place on segments of arrays that start and end at specified indices. In the QuickSort implementation, the end index was inclusive, while it was exclusive in MergeSort and InsertionSort. This has been fixed in this changeset to make the end index exclusive in all three implementations, following the convention in the Java Collections library.” Version 0.16.0 This version implements major changes; most importantly, Scala 2.10 has been dropped. The commutative ring tower has been precised: Euclidean division has better semantics, and unique factorization domains have been introduced, generalizing spire.math.prime. Some species of division with remainder are now described by TruncatedDivision. An involution typeclass abstracts over complex conjugation. We also revised the use of commutative vs. noncommtutative rings, mostly in the construction of complex numbers/quaternions, and in the definition of modules. Preliminary work has been done towards the modularization of Spire. A platform module abstracts over the JVM/JS differences, while Opt has been moved to the util module. Other modules are not used yet (data, legacy) but will be in the future. Removed support for Scala 2.10 Upgraded SBT version to 1.1.5 Upgraded to Scala 2.12.6 Introduced the platform and util modules Added a few modules for future modularization: legacy, data Introduced unique factorization domains. Renamed quot/mod to equot/emod (Euclidean rings). Introduced principled truncated division semantics (see https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf ). Added return types to public methods Version upgrades for Scalacheck, Scalatest, Shapeless, Discipline, Machinist and Scala versions Added a docs project using tut, README is compiled under tut. Bug fixes to signum Fixes to Modules (i.e. generalizations of vector spaces) with respect to commutativity, introduced left and right modules Complex numbers and quaternions are now defined on a commutative ring Introduced limited range tests for primitive types, Involution typeclass Version 0.15.0 This version upgrades dependencies to algebra 1.0.0 which supports the cats 1.0 release. Upgraded to algebra 1.0.0 Small bug fixes to intervals, sparse polynomials, complex numbers, big decimals Version 0.14.1 This version add laws for gcd/lcm operations, and fixes corner cases for the standard types such as Rational. Additions: Law tests for gcd/lcm Changes: gcd/lcm are associative and commutative, the Rational gcd/lcm have been aligned to be compatible with the integer gcd/lcm. Corner cases such as gcd(a, 0) are handled correctly Version 0.14.0 This release is a major milestone for Spire. First of all, it introduces a dependency on typelevel/algebra (and thus on typelevel/cats-kernel). This provides immediate compatibility with Cats and Algebird. Second of all, Spire is now published to the org.typelevel organization (which was previously org.spire-math). Additions: Added GCDRing, part of the commutative ring hierarchy Clarified the laws of EuclideanRing Added DivisionRing, a ring in which division is possible (generalization of fields to the noncommutative case; used now by Spire’s quaternions). Changes: Many type classes are now aliases to algebra’s type classes Algebra provides commutative rings and fields, but the intemediate structures (GCDRing/EuclideanRing) are added by Spire; thus Spire Field differs from algebra Field by extending GCDRing and EuclideanRing. The EuclidenRing operations for Field have been corrected; in particular, Float, Double no longer perform truncated division but a /~ b = 0 for nonzero b, as a can always be divided by b in a field. Signed now extends Order, thus IsReal only extends Signed. IsReal has been replaced by Signed for some operations in e.g. Complex, making them more precise/general. Many different efficiency improvements Fixes: Instances for Complex and Quaternion are more precise Numeric[Complex[A]] is no longer provided Many bug fixes Version 0.13.0 Additions: Added Eq[Bound[A]] instance Added Interval#overlap and supporting machinery Changes: Improve Polynomial performance Support negative roots for Real Migrate to newer ScalaCheck Fixes: Fix bugs in root isolation/refinement for Algebraic Speed up convergence for Rational#limitTo Version 0.12.0 Additions: IntervalSeq and IntervalTrie added to spire-extras .toReal and .toAlgebraic methods on Rational Changes: Package restructuring and improvements Make Interval serializable Deprecate use of SecureJava.fromBytes Fixes: Numerous bug fixes Version 0.11.0 Spire has two new core maintainers: Rüdiger Klaehn and Denis Rosset. The spire-scalacheck-binding package has been renamed to spire-laws. The spire-extras package has been introduced, for types that are less widely-used (but still useful). Additions: Added spire.math.Merging for merging arrays Added qcombine (for generic Monoids) More benchmarks (Rational, SafeLong, …) Scalastyle plugin and code clean up Scoverage plugin and coverage tracking Type class instances for java.math.BigInteger Useful .as syntax for converting literals Changes: Move FixedPoint into extras Improve Rational implemenation (clearer structure, faster) Fixes: Improved equality (===) support Lots of documentation bug fixes and typo correction Fixed unary - for unsigned int/long Clean up Arbitrary/Gen instances Drastically-improved test coverage for SafeLong, Rational, etc. Fixed bugs around ceil method Version 0.10.1 (Version 0.10.0 was aborted due to errors during the release.) Fixes: Major refactor/improvements to Algebraic (Tom Switzer) Remove unneeded imports (Kenji Yoshida) Fix SBT build (Kenji Yoshida) Update README to display correct mailing list (Pablo Pita) Remove superfluous Interval#min param (Siddhartha Gadgil) Fix code examples in README (Kevin Meredith) Add support for pattern matching SafeLong (Kevin Meredith) Improve Opt and add tests (Alec Zorab) Fix tail recursion with Opt (Kenji Yoshida) Remove ApproximationContext entirely (Erik Osheim) Update sbt, scala and library versions (Kazuhiro Sera) Fix hashCode/equals for polynomials (Erik Osheim) Add pretty stringifcation to polynomials (Rüdiger Klaehn) Many new polynomial tests (Rüdiger Klaehn) Fix cooperative equality on Rational (Erik Osheim) Create DESIGN.md for implementation docs (Rüdiger Klaehn) Improve Interval tests, fix bugs (Denis Rosset) Add PCG-based Generator (Alexey Romanov) Fix Float/Double GCD bugs (Tom Switzer) Improve SafeLong test coverage (Erik Osheim) Improve Rational test coverage, fix bugs (Rüdiger Klaehn) Many Rational efficiency improvements (Rüdiger Klaehn) Add scoverage support (Rüdiger Klaehn) Fix ULong bugs (Erik Osheim) Version 0.9.1 Interval bug fixes (Denis Rosset) Efficiency improvements for Rational (Rüdiger Klaehn) Improve and document NumberTag (Tom Switzer) Add support and tests for partial actions (Denis Rosset) Add Opt[_] type for unboxed optional values (Denis Rosset) Add Gitter chat room to README (Erik Osheim) Fix bug with root-finding for Long values (Erik Osheim) Version 0.9.0 The project now builds with Scala 2.11.4 by default. This was a major update with many additions, changes, and bug fixes. Additions: Added and reworked group actions (Denis Rosset) Add Lattices and Heyting algebras (Erik Osheim) More useful symbolic operators (Erik Osheim) Introduce Exponential[A] distribution (Erik Osheim) Introduce NumberTag[A] type class (Erik Osheim) Fixes: Fix typos (Ben Barnard) Fix possible overflow for Complex norm (William Waites) Reduce macro warnings building Spire (Erik Osheim &amp; Tom Switzer) Add missing Number implicits (Erik Osheim) Replace sys.error with proper Exceptions (Tom Switzer) Fix Rational(0D) constructor bug (Tom Switzer) Fix Trilean bug (Erik Osheim) Fix SafeLong bugs (Erik Osheim) Fix Jet bugs (Robert Garden &amp; Erik Osheim) Fix Interval parsing (Ruediger Klaehn) Changes: Major interval improvements and bug fixes (Denis Rosset) Improve Gaussian[A] distribution using Ziggurat (Erik Osheim) Use aggreate instead of fold to enable parallelism (Adam Pingel) Clarified and improved partial orders (Denis Rosset) Improve Checked arithmetic macros (Tom Switzer &amp; Erik Osheim) Remove almost all closure allocations in SafeLong (Erik Osheim) Made type classes universal traits where possible Update library dependency versions Version 0.8.2 The project now builds for 2.11.2 by default. Additions: added Well1024a, Well19937a, Well19937c, Well44497a, and Well44497b generators (Dušan Kysel) added Ziggurat generator for random variables with Gaussian and Exponential distributions (Dušan Kysel) added PartialOrder[A] (Denis Rosset) added free algebras (Tom Switzer) added optional unicode operators (Erik Osheim) added Trilean, a three-valued logic type (Erik Osheim) added segmented sieve for prime generation (Erik Osheim) added Random[A] monad (Erik Osheim) Fixes: specialized GroupAction (Tom Switzer) improved Well512a implementation (Dušan Kysel) Interval[A] bug fixes (Denis Rosset and Erik Osheim) major improvements to FpFilter and related machinery (Tom Switzer) standardized numeric conversions (Erik Osheim) Changes: renamed BooleanAlgebra[A] -&gt; Bool[A] (Erik Osheim) migrated to machinist for ops support (Erik Osheim) refactored spire.random package structure (Erik Osheim) (Versions 0.8.0 and 0.8.1 were skipped due to release problems.) Version 0.7.5 (Need to reconstruct these notes for versions 0.7.5 and earlier.)"
    } ,    
    {
      "title": "Contributing",
      "url": "/spire/extra_md/contributing.html",
      "content": "Contributing to Spire This document is a guide to how to get started contributing to Spire. Writing guides or documentation Often the biggest issue facing open-source projects is a lack of good documentation, and Spire is no exception here. If you have ideas for specific pieces of documentation which are absent, feel free to open a specific issue for that. We also gladly accept patches for documentation. Anything from fixing a typo to writing a full tutorial is a great way to help the project. The documentation lives in the docs/src/main/mdoc directory in the repository. To preview the website locally: Install Jekyll v4. Run sbt docs/makeMicrosite. Change directory to docs/target/site and run jekyll serve -b /spire. Preview website at http://localhost:4000/spire. Reporting bugs, issues, or unexpected behavior If you encounter anything that is broken, confusing, or could be better, you should open an issue. You don’t have to know why the error is occurring, or even that an error happens at all. If you are trying to do something with Spire, and are having a hard time, it could be any of the following issues: an actual bug or error an omission or problem with the API a confusing edge case a documentation problem Feel free to open a bug before you’re sure which of these is happening. You can also ask questions on the #spire channel on the Typelevel Discord to get other people’s opinions. Creating or improving tests Spire uses munit and ScalaCheck to test our code. The tests fulfill a number of important functions: ensure our algorithms return correct results check the visibility of our type class instances confirm that the API works as we expect test edge cases which might otherwise be missed If you find a bug you are also encouraged to submit a test case (the code you tried that failed). Adding these failing cases to Spire’s tests provides a good way to ensure the bug is really fixed, and is also a good opportunity to start contributing. ALso, when you notice places that lack tests (or where the tests are sparse, incomplete, or just ugly) feel free to submit a pull request with improvements! Submitting patches or code Spire is on Github to make it easy to fork the code and change it. There are very few requirements but here are some suggestions for what makes a good pull request. If you’re writing a small amount of code to fix a bug, feel free to just open a pull request immediately. You can even attach some code snippets to the issue if that’s easier. For adding new code to Spire, it’s often smart to create a topic branch that can be used to collaborate on the design. Features that require a lot of code, or which represent a big change to Spire, tend not to get merged to main as quickly. For this kind of work, you should submit a pull request from your branch, but we will probably leave the PR open for awhile while commenting on it. You can always message the #spire channel on the Typelevel Discord to get a second opinion on your idea or design. Ask questions and make suggestions Spire strives to be an excellent part of the Scala ecosystem. We welcome your questions about how Spire works now, and your ideas for how to make it even better!"
    } ,    
    {
      "title": "Design notes",
      "url": "/spire/extra_md/design.html",
      "content": "Design This document is intended to describe design goals, invariants and implementation notes for the various types SafeLong The design goal of SafeLong is to provide worry-free arbitrary precision integers that nevertheless have performance approaching boxed Longs for calculations that remain within the range of a 64bit signed integer. This is achieved by having two cases: SafeLongLong(x: Long) is used for numbers within the long range. SafeLongBigInt(x: BigInt) is used if this is not the case. Invariants A number in the long range must always be represented as a SafeLongLong. This is used both within the SafeLong operations and from other classes in spire.math. Consequences of this invariant are SafeLongBigInt can never be zero A SafeLongBigInt can never be equal to a SafeLongLong Implementation notes Operations of SafeLongBigInt use the underyling BigInt and create the appropriate kind of result depending on whether the result is a valid long. Operations on SafeLongLong use the Checked macro to perform operations using long integers, and only fall back to using BigInt in case of numeric overflow. Performance tips comparison to zero is more efficient using signum than using compare the isValidLong method can be used to check if a SafeLong can be losslessly converted to a long using toLong Rational The design goal of Rational is to provide good performance and low memory overhead in the very frequent case of rational numbers with small magnitude, while still being able to represent rational numbers of arbitrary size. To achieve this goal, there are two different cases. LongRational(n: Long, d: Long) is used to represent small rational numbers. BigRational(n: BigInt, d: BigInt) is used whenever either numerator or denominator are too large to be stored in a LongRational. Invariants Rationals are always stored in a normalized form so that there is an unique representation for each number: Common factors of numerator and denominator are eliminated, so e.g. 3/9 is stored as n = 1, d = 3 Negative rational numbers are always stored as a negative numerator. Therefore the denominator is always positive A rational number with a zero denominator is invalid Zero will always be stored as n = 0, d = 1 In addition to these invariants that are quite common in many rational implementations, there are additional invariants related to the usage of LongRational or BigRational: Every rational number that can be stored in a LongRational given the invariants above will always be stored in a LongRational. Consequences of this are: The valid range for the numerator is [Long.MinValue, Long.MaxValue] and for the denominator [1, Long.MaxValue]. Since the denominator is always stored as a positive number, e.g. Rational(1, Long.MinValue) must be stored as a BigRational A BigRational can never be equal to a LongRational The numerator of a BigRational can never be zero, since zero is always represented as LongRational(0, 1) When implementing operations for Rationals, it is important to make sure that the invariants are not violated. E.g. when performing an operation with two BigRational that results in a small number that can be represented in a LongRational, the result must be a LongRational. Implementation notes The implementation of BigRational is pretty straightforward. Usually, operations will be performed using SafeLong, and the result will be created using a builder method that takes a SafeLong for both numerator and denominator and produces the right kind of rational number given the invariants. LongRational operations are a bit more complex: Basic operations use the Checked macro to try to perform the operation with just long integers, and only fall back to using SafeLong when there is a numeric overflow. The advantage of this approach is that there are no unnecessary object allocations in the very common case that there is no overflow. Performance tips The performance characteristics of rational operations are a bit different to normal integer or floating point operations. the basic operations +,-,*,/ have roughly the same cost comparison is cheaper than the basic operations, and will not allocate any objects for small rational numbers comparison to zero is more efficient using signum than using compare comparison to one is best done with the compareToOne method instead of using compare"
    } ,    
    {
      "title": "Friends of Spire",
      "url": "/spire/extra_md/friends.html",
      "content": "Friends of Spire Here is a list of libraries that are based on Spire, or have Spire compatibility. Libra, dimensional analysis for Scala coulomb coulomb: unit analysis for Scala circe-spire circe encoders and decoders for Spire types onnx-scala An ONNX (Open Neural Network eXchange) API and backend for typeful, functional deep learning in Scala (3) NDScala N-dimensional arrays in Scala 3. Think NumPy ndarray, but with compile-time type-checking/inference over shapes, ndarray/axis labels &amp; numeric data types Sonic reducer, Hierarchical reducer for arbitrary Scala sequences spire-matrix, BLAS-backed implementation of VectorSpace. See #675. POC/Not for prod use."
    } ,    
    {
      "title": "Guide",
      "url": "/spire/guide.html",
      "content": "Spire User’s Guide This guide explains the architecture, layout, and usage of Spire. Initially, we will explore some of the basic structures and patterns used by Spire. Then, we’ll look at many of the concrete types that Spire defines. Finally, we’ll peek at some of the advanced or tricky corners of the library. Type Classes Like many Scala libraries, Spire uses type classes to define generic operations. These code examples all assume the following imports: import spire.algebra._ // all type class definitions import spire.implicits._ // all type class instances and syntax For example, Ring[A] is a type class that defines many basic operations, such as + and * on a type A. When using type classes it’s important to try to distinguish the following: The type class itself (Ring[A]). This is often a trait. Concrete instances of the type class, such as Ring[Int]. Syntax implicits that use the type class to define operators. The methods in these type classes are always given text names (like plus). In some cases these names correspond to symbolic operators: in the case of plus, it corresponds with +. When using these type classes, users have the option of using the symbolic syntax on the values directly or calling the method on the type class instance: def usingSymbols[A: Ring](x: A, y: A): A = x + y def usingNames[A](x: A, y: A)(implicit r: Ring[A]): A = r.plus(x, y) Some methods (e.g. sqrt) do not have corresponding symbols. In those cases, the method name itself can be used with the values: def sqrt[A: NRoot](x: A): A = x.sqrt Package Layout In the case of Ring[A], the type class itself is located in spire.algebra. Except for a few special cases, all of Spire’s type classes can be found in spire.algebra. Type class instances can be found in two different places. For types defined in Spire, or code that is aware of Spire, type class instances should be placed in the type’s companion object. For example, UByte (an unsigned byte type) has an instance of Rig[UByte] contained in its companion object. For types defined elsewhere that Spire supports directly (for example the built-in number types) Spire defines objects in spire.std which contain their instances. So to get all the instances for Int you’d import them from spire.std.int._. To get all these “standard instances” at one go, import spire.std.any._. This pattern should also be used when supporting other number types that are not Spire-aware. Finally, syntax implicits are imported from objects in spire.syntax. To get the syntax for Ring[A] you’d import spire.syntax.ring._. Again, there is a shortcut package: you can import spire.syntax.all._ to get all syntax. These imports might seem a bit confusing, but they are very useful when you find a situation where Spire’s types or operators conflict with another library’s. We provide an even more basic import (spire.implicits._) for when you want all instances and all operators. This is nice when working in the console or experimenting, and for when you’re sure there won’t be a conflict. Usage Most of the time, you’ll be using type classes as context bounds. For instance: object Demo { import spire.algebra._ import spire.std.any._ import spire.syntax.ring._ def double[A: Ring](x: A): A = x + x def triple[A: Ring](x: A): A = x * 3 println((double(3), triple(4))) } This code ends up being equivalent to: object Demo2 { def double[A](x: A)(implicit ev: Ring[A]): A = ev.plus(x, x) def triple[A](x: A)(implicit ev: Ring[A]): A = ev.times(x, ev.fromInt(3)) println((double(3)(IntAlgebra), triple(4)(IntAlgebra))) } The IntAlgebra type extends Ring[Int] and has been imported via spire.std.any._. The implicits providing the binary operators + and * (and also the implicit to convert the integer literal into an A) were all imported form spire.syntax.ring._. And the Ring context bound is really just sugar for an implicit parameter (the type class instance). Hopefully this small example gives you an idea of the basic mechanics behind Spire’s generic math capabilities. Specialization To achieve speed on-par with direct (non-generic) code, you will need to use specialization. The good news is that most of Spire’s code is already specialized (and tested for proper performance). The bad news is that you’ll have to annotate all your generic code like so: object Demo3 { import spire.algebra._ import spire.std.any._ import spire.syntax.ring._ import scala.{specialized =&gt; sp} def double[@sp A: Ring](x: A): A = x + x def triple[@sp A: Ring](x: A): A = x * 3 println((double(3), triple(4))) } There are too many gotchas with specialization to list here. But the (very) short guide to specialization is: It’s much easier to specialize methods. Calls from generic code into specialized code are not specialized. Limit specialization to types you’ll use via @sp(Int, Double). Specialization will increase bytecode size by a factor of x2-10. If you have questions about specialization feel free to ask on the #spire channel on the Typelevel Discord. You may notice that some code in Spire is structured in an unusual way, and often this is to make sure specialization works properly. You may find that it’s easy to develop generic code without using specialization first (to keep things simple) and then going back and adding annotations later if necessary. This helps keep things simple while you get your code working correctly, and it’s a (relatively) minor change to enable specialization later (as long as you are consistent). Of course, if your code is not generic, you can call into Spire’s specialized code without worrying about any of this (and the result will be unboxed and fast). Type Classes Properties Spire’s type classes are often described in terms of properties (or “laws”). These properties must be true no matter what values are used. Here’s a brief description of some of the most common properties: associativity: |+| is associative if (a |+| b) |+| c = a |+| (b |+| c). identity: id is an identity value for |+| if a |+| id = a = id |+| a. inverse: |+| has an inverse operation if a |+| a.inverse = id = a.inverse |+| a. commutativity: |+| is commutative if a |+| b = b |+| a. In some cases the operator names are different (e.g. +, *) but the properties themselves remain the same. Eq Spire provides an Eq[A] type class to represent type-safe equality. This allows us to talk about types for which there isn’t a computationally useful notion of equality, and also to avoid programming errors caused by universal equality. Eq[A] provides two operators eqv (a === b) equality operator. neqv (a =!= b) inequality operator (defaults to !(a === b)). Spire requires that eqv obey the laws of an equivalence relation, namely: a === a (reflexivity) if a === b then b === a (symmetry) if a === b then a is b (anti-symmetry) if a === b and b === c then a === c (transitivity) The anti-symmetry property may seem confusing. The idea is that if a === b then a and b must be substitutable for each other, such that for any expression f(x), f(a) === f(b). Order Total orderings in Spire are supported by the Order[A] type class. Unlike other ordering type classes (e.g. scala.math.Ordering), this one is specialized to avoid boxing. Order[A] extends Eq[A] can be implemented via a single compare method, although it provides all of the following: eqv (a === b) neqv (a =!= b) lt (a &lt; b) gt (a &gt; b) lteqv (a &lt;= b) gteqv (a &gt;= b) compare (a compare b) min (a min b) max (a max b) Instances of Order[A] are required to observe the following properties: if a &lt;= b and b &lt;= a then a === b (anti-symmetry) if a &lt;= b and b &lt;= c then a &lt;= c (transitivity) either a &lt;= b or b &lt;= a (totality) Additionally, total orderings across fields should obey the following additional laws: if a &lt;= b then (a + c) &lt;= (b + c) (O1) if zero &lt;= a and zero &lt;= b then zero &lt;= (a * b) (O2) (These are laws are required by ordered fields.) In some cases users may need to use (or define) total orderings that do not follow all these laws, or may break laws required by other structures. An example would be the lexicographic ordering of complex numbers, which breaks O2. In these cases, users will need to be aware of the risks and limit their use to situations where the particular law is not needed. Signed Translation-invariant total orders are captured by the Signed[A] type class. In general, the type A is equipped with a commutative additive operation + and a zero element 0 (see the definition of commutative rings below). The following laws hold: if a &lt;= b then a + c &lt;= b + c (linear order), signum(x) = -1 if x &lt; 0, signum(x) = 1 if x &gt; 0, signum(x) = 0 otherwise. If the type A is equipped with negative elements -x, then we have: abs(x) = -x if x &lt; 0, or x otherwise, The above laws imply: abs(a + b) &lt;= abs(a) + abs(b) PartialOrder Partial orderings in Spire are supported by the PartialOrder[A] type class. Its implementation differs from scala.math.PartialOrdering in two features: PartialOrder is specialized to avoid boxing, and the partialCompare method returns a Double and avoids allocation of an Option[Int] instance. PartialOrder[A] extends Eq[A], and can be implemented via a single partialCompare method, described below. PartialOrder provides: eqv (a === b) neqv (a =!= b) lt (a &lt; b) gt (a &gt; b) lteqv (a &lt;= b) gteqv (a &gt;= b) partialCompare (a partialCompare b) tryCompare (a tryCompare b) pmin (a pmin b) – returns the least element if they can be compared pmax (a pmax b) – returns the greatest element if they can be compared A partial order is defined from a binary relation &lt;=, which satisfies the relations: a &lt;= a (reflexivity) if a &lt;= b and b &lt;= a, then a === c (anti-symmetry) if a &lt;= b and b &lt;= c, then a &lt;= c (transitivity) To compute both &lt;= and &gt;= at the same time, the method partialCompare uses a Double number to encode the result of both comparisons. The truth table is defined as follows: a &lt;= b a &gt;= b partialCompare(a, b) corresponds to true true 0 a === b false false NaN a incomparable with b true false -1 a &lt; b false true 1 a &gt; b The method tryCompare returns maps -1.0, 0.0, 1.0 to Some(-1), Some(0), Some(1), and NaN to None, allowing the use of getOrElse and higher-order methods, at the price of an Option[Int] allocation. Instances of PartialOrder[A] are required to observe the properties above. Note that Order[A] extends PartialOrder[A], but for pedagogical purposes, Order[A] is presented first in this guide. Groups The most basic algebraic type classes Spire supports involve a single associative binary operator (called op and represented as |+|): Semigroup[A] just the associative operator |+|, nothing more. Monoid[A] a semigroup that also has an identity element id. Group[A] a monoid that also has an inverse operation (inverse or |-|). CSemigroup[A] a semigroup that is commutative. CMonoid[A] a monoid that is commutative. AbGroup[A] an “abelian group”, a group that is commutative. Most types have many possible implementations of these types classes. In these cases Spire requires users to explicitly choose which implementation they want. Spire also defines two parallel group hierarchies for additive and multiplicative groups. These have the same properties but different names and symbols. The following list provides the generic, additive, and multiplicative variants: operator method: op, plus, times operator symbol: |+|, +, * identity name: id, zero, one inverse method: inverse, negate, reciprocal inverse symbol: inverse, - (unary), reciprocal inverse binary operator: |-|, - (binary), / Rings and Fields Rings are a set together with two binary operation (additive and multiplicative). Spire defines these by extending the appropriate additive and multiplicative group traits. The following list roughly describes the Ring-like type classes Spire provides: Semiring[A] provides +, zero, and *. Rig[A] provides +, zero, *, and one. Rng[A] provides commutative +, zero, -, and *. Ring[A] provides commutative +, zero, -, *, and one. CRing[A] provides commutative +, zero, -, commutative *, and one. The following list makes clear how these type classes are defined via inheritance: Semiring[A] extends AdditiveMonoid[A] with MultiplicativeSemigroup[A] Rig[A] extends Semiring[A] with MultiplicativeMonoid[A] Rng[A] extends Semiring[A] with AdditiveAbGroup[A] Ring[A] extends Rig[A] with Rng[A] CRing[A] extends Ring[A] with MultiplicativeCMonoid[A] Rings also provide a pow method (**) for doing repeated multiplication. Commutative ring hierarchy Commutative rings (also called domains in the literature) have a rich structure. Spire focuses on the structures relevant for computational algebra (GCD rings, Euclidean rings and fields). GCDRing[A] extends CRing[A] EuclideanRing[A] extends GCDRing[A] spire.Field[A] extends algebra.Field[A] with EuclideanRing[A] GCDRings GCDRings are commutative rings (CRing[A]) with existence of a greatest-common-divisor and least-common-multiple. Spire’s GCDRing[A] supports the following operations: gcd (a gcd b) find the greatest common divisor of a and b. lcm (a lcm b) find the lowest common multiple of a and b. obeying the following laws: d * m === a * b for d = gcd(a, b) and m = lcm(a, b), gcd is associative and commutative, lcm is associative and commutative. Note that the gcd is defined up to a divisible element (unit); in particular, its sign is a matter of convention. Spire requires these operations to be commutative. Note that fields have leeway to define the GCD operation. In practice, instances of Field[A] provide either a trivial implementation gcd(x != 0 , y != 0) == 1 or a definition that extends the one used for the integer ring (gcd(a/b, c/d) == gcd(a, c)/lcm(b, d)). EuclideanRings Spire supports euclidean domains (called EuclideanRing[A]). A euclidean domain is a GCD ring (GCDRing[A]) that also supports euclidean division (e.g. floor division or integer division). This structure generalizes many useful properties of the integers (for instance, quotients and remainders, and greatest common divisors). Formally, euclidean domains have a euclidean function f such that for any x and y in A, if y is nonzero, then there are q and r (quotient and remainder) such that a = b*q + r and r = 0 or f(r) &lt; f(b). For integers, f is usually the absolute value function. Spire’s EuclideanRing[A] supports the following operations: quot (a /~ b) finding the quotient. mod (a % b) the remainder from the quotient operation. quotmod (a /% b) combines quot and mod into one operation. Spire requires that b * (a /~ b) + (a % b) is equivalent to a. On integers, Euclidean quotient and remainder corresponds to truncated division; however, the sign of the result is a matter of convention. On rational (or floating-point) numbers, a /~ b = a / b and a % b = 0 by definition. Fields Fields are commutative rings with commutative multiplication and multiplicative inverses for all non-zero elements. Fields generalize how most people think about rational numbers. Spire’s Field[A] supports the following operations: div (a / b) divide a by b. reciprocal (a.reciprocal) the multiplicative inverse of a, i.e. one/a. Even though fields sit at the top of the ring hierarchy, there are many operations which are not provided by fields: equality and ordering (provided by Eq[A] and Order[A]). square root, and other roots (provided by NRoot[A]). sine, cosine, and trigonometric functions (provided by Trig[A]). Irrational and Transcendental type classes Spire supports square roots and fractional powers via NRoot[A]. There are three basic methods available: sqrt (a.sqrt) finds the square root of a nroot ((a nroot k)) finds the kth root of a fpow ((a fpow b)) takes a to the fractional power b Spire does not have any fractional types that can represent irrational roots exactly. This means that many laws we might like to write about roots will be weaker than we would like: a.sqrt = (a nroot 2) = (a fpow 2.reciprocal) if A can represent 1/k exactly, then (a nroot k) = (a fpow k.reciprocal) if (a nroot k) is rational, then (a nroot k).pow(k) = a Approximate types like Double and BigDecimal have a built-in precision to which Spire can find roots. Exact types like Rational do not have NRoot instances defined by default, but instances can be instantiated with user-provided precision. Similarly, Spire supports the Trigonometric functions via Trig[A]. The preceding caveats about precision apply to these functions and values as well. The following methods are supported: e Euler’s number pi Ratio of a circle’s diameter to its circumference. exp(a) Raise e to a-th power. expm1(a) Equivalent to exp(a) - 1 with less error. log(a) Find the natural logarithm of a (r such that expr(r) = a) log1p(a) Equivalent to log(1 + a) but with less error. sin(a) Sine: the y-coordinate of the unit circle. cos(a) Cosine: the x-coordinate of the unit circle. tan(a) Tangent: equivalent to sin(a) / cos(a). asin(a) inverse sine function, asin(sin(a)) = a. acos(a) inverse cosine function, acos(cos(a)) = a. atan(a) inverse tangent function, atan(tan(a)) = a. atan2(y, x) like atan but returns results in (-pi, pi]. sinh(x) hyperbolic sine, y-coordinate of the unit hyperbola. cosh(x) hyperbolic cosine, x-coordinate of the unit hyperbola. tanh(x) hyperbolic tangent, sinh(a) / cosh(a). toRadians(a) convert degrees (e.g. 180) to pi-radians (e.g. pi) toDegrees(a) convert pi-radians (e.g. pi/2) to degrees (e.g. 90). Spire is able to calculate trigonometric values (like pi) and functions (like sine) to arbitrary precision when using BigDecimal. Unlike with NRoot, there is no support for creating Trig[Rational] instances with arbitrary precision (although an instance with Double precision can be found in spire.optional.rationalTrig). Modules, VectorSpaces, &amp;co TODO Types This section attempts to chronicle the existing number types in terms of their capabilities and problems. Byte, Short, Int, and Long These built-in integral types are all signed and have a fixed-width (8, 16, 32, and 64 bits respectively). Division with these types is truncated, and overflow can silently occur when numbers to get too big (or too small). Division by zero will trigger an exception. It’s worth noting that the JVM does not support operating on Byte and Short directly: these operations will usually return Int. This can cause confusion when using type inference, and can also lead to differences between direct code (where adding bytes produces an int) and generic code (where adding bytes produces a byte). Float and Double These fractional types correspond to IEEE-754 floating point (32- and 64-bit respectively). They contain three sentinel values: positive and negative infinity and NaN. Large positive and negative quantities will overflow to their respective infinity value, and division by zero will silently go to infinity. Comparison and equality semantics for NaN are tricky (for example NaN == NaN is false). This also means that there is no total ordering for doubles that complies with IEEE comparisons. For an alternate Ordering[Double] that is total, see spire.optional.totalfloat. Since floating-point values are approximations of real values, loss of precision can occur when adding values of different magnitudes. Thus, many operations are not always associative. Spire assumes that users who work with Float and Double are aware of these problems, and provides instances like Ring[Double] even though it will fail to be associative in some cases. BigInt This integral type is unbounded–it will never overflow (although operations will get slower and slower as the value gets larger). This is probably one of the least difficult types to use correctly. BigDecimal This fractional type is different than the previous floating point values. It contains a MathContext object which specifies a certain number of decimal digits of precision (34 by default). Results will be rounded to this level of precision, which also makes this type not associative in some cases (although with user-specified precision it is easier to avoid cases where this matters). The math context also defines how values should be rounded. Since this type is decimal, it can exactly represent any decimal number (unlike a floating point value) although its math context will need enough digits to do so. As with floating point, Spire makes a best effort to support this type even though there may be problems related to precision and rounding. Spire also provides capabilities which the underlying type lacks, including roots, fractional powers, and trigonometric methods. Rational This fractional type represents a rational number, a fraction of two integers (n/d). It is an exact type, although as you might expect it can’t represent irrational numbers without approximating them as rationals. It is unbounded, although as the fraction becomes larger or more complex, operations will become slower. Rationals are always stored in simplest form to speed up future calculations. This is probably the easiest fractional type to use correctly. SafeLong This integral type is also unbounded, like BigInt. However, it is more efficient for small values, where it will use a Long instead. There is usually no reason to prefer using a BigInt over a SafeLong except to comply with an external API, or in cases where most values are expected to exceed a long’s storage capacity. Natural This is a simple unbounded, unsigned integral type. It models natural numbers a as a cons list of digits (each “digit” being a 32-bit unsigned integer). For relatively small values (32-128 bits) it is often faster than SafeLong or BigInt. For larger values it becomes slower. The Natural type a bit of an odd-ball type at present. However the fact that it is guaranteed to be non-negative is useful. UByte, UShort, UInt, and ULong These unsigned integral types are provided by Spire. They have most of the same operations as their signed counterparts, although they use unsigned division which is a bit more involved. They are value classes, so in most cases there should be no extra overhead when compared with their primitive counterparts. The one exception is with arrays. Array[UInt] will be boxed whereas Array[Int] is not. Since conversions between UInt and Int only exit at compile-time, it’s easy to work around this issue by storing UInt instances in an Array[Int]. Writing literal unsigned values is slightly more cumbersome than their signed counterparts (consider UInt(7) versus 7). Spire provides syntax imports which make these slightly easier to write: import spire.syntax.literals._ ui\"7\" // equivalent to UInt(7) // res0: UInt = 7 FixedPoint This value class uses a Long with an implicit denominator. The type itself doesn’t contain information about the denominator. Instead, an implicit FixedScale instance is required to provide that context when necessary (for instance, during multiplication). Like the previous unsigned values, fixed point values will not be boxed in most cases. This type is designed to solve a specific type of problem and should only be used in situations where a large number of rational numbers with the same denominator are needed, and efficiency is very important. Complex[A] and Quaternion[A] These generic types represent complex numbers (x + yi) and quaternions (w + xi + xj + zk) respectively. They can be parameterized with any fractional type A which has a Field[A], NRoot[A], and Trig[A]. In general these values are as exact as their underlying A values are, although in some cases approximate results are necessarily returned (in cases where roots or trigonometry functions are used). These types are specialized, so most operations should be quite fast and not cause unnecessary boxing. However, these types use more memory than a non-generic complex number based on Double values would, and are a bit slower. Number This is a boxed number type that approximates the semantics of numbers in a dynamically-typed numeric tower (like Scheme or Python). There are four subtypes of Number, based on SafeLong, Double, BigDecimal, and Rational. Combining two numbers will always return a number of the highest precision. Number is a good choice for users who want simple and correct numbers. The type keeps operations as safe as possible, while providing access to all operators and methods. Interval[A] Interval supports arithmetic across a range of possible A values. This can be thought of as representing uncertainty about a single, actual value, or as operating on the entire set of values simultaneously. Any type that has an Order[A] can be used in an interval, although most arithmetic operations will require additional type classes (ranging from AdditiveSemigroup[A] for + to Field[A] for /). Intervals may be unbounded on either side, and bounds can be open or closed. (An interval includes closed boundaries, but not open boundaries). Here are some string representations of various intervals: [3, 6] the set of values between 3 and 6 (including both). (2, 4) the set of values between 2 and 4 (excluding both). [1, 2) half-open set, including 1 but not 2. (-∞, 5) the set of values less than 5. Intervals model continuous spaces, even if the type A is discrete. So for instance when (3, 4) is an Interval[Int] it is not considered “empty” , even though there are no Int values between 3 and 4. This is because we can multiply the interval by 2 to get (6, 8) which is clearly not empty. The underlying continuous interval contains values which when multiplied by a scalar become valid Int values. Polynomial[C] Currently Spire supports univariate polynomials. These are polynomials with a single variable (e.g. x) with the following structure: c0 + (c1 * x^1) + (c2 * x^2) + ... + (cn * x^n) The coefficients (c0 through cn) are values of the type C, and the exponents (1 through n) are Int values (this does mean that Spire’s implementation only supports polynomials whose exponents are less than 2147483648). Like interval, arithmetic on polynomials is accomplished using type classes for C, such as Semiring[C]. With the right type classes, polynomials can support all the arithmetic operations covered by euclidean rings, but not fields. Division and reciprocal operations are impossible because polynomials do not support fractional or negative exponents. Polynomials also support interval, derivative, and other operations. Spire does support a convenient syntax for literal polynomials. By importing spire.syntax.literals._ (or just spire.implicits._) you can use the poly string interpolator to create Polynomial[Rational] instances: import spire.syntax.literals._ poly\"3x^2 - 5x + 1\" // res1: Polynomial[Rational] = PolySparse(Array(0, 1, 2), Array(1, -5, 3)) poly\"5/4x^6 - 7x - 2\" // res2: Polynomial[Rational] = PolySparse(Array(0, 1, 6), Array(-2, -7, 5/4)) poly\"1.2x^3 - 6.1x^2 + 9x - 3.33\" // res3: Polynomial[Rational] = PolySparse( // Array(0, 1, 2, 3), // Array(-333/100, 9, -61/10, 6/5) // ) Spire actually supports two types of polynomials: dense and sparse. For most simple polynomials used in these examples, you’ll probably want dense polynomials. However, in cases where your polynomials have a few terms with very large exponents the sparse implementation will be more efficient. In any case, the underlying representation is an implementation detail and both types support the same operations (and can interoperate). Algebraic The Algebraic type is an implementation of a number for “Exact Geometric Computation”. It represents algebraic numbers using an AST of the operations performed on it. Algebraic numbers can be compared accurately and exactly. This means that if we have two numbers a and b, then a compare b is always correct, regardless of whether they are irrational or incredibly close to each other. They are suitable for use in algorithms that use square- or n-roots and rely on sign tests and numeric comparison to work correctly. On top of exact comparisons/sign tests, Algebraic is able to approximate itself to any desired precision, after the fact. This works for both absolute approximations, such as x +/- 0.00001, or relative approximations, such as x.toBigDecimal(new MathContext(10000)). Because Algebraic can represent algebraic numbers (note: we are adding support for polynomial roots, not just n-roots), they have a wider range than Rational. However, whereas Rational represents numbers exactly, Algebraic can only compare exactly. They also sacrifice performance to achieve this, and so are not suitable for use where you need performance and can tolerate a certain amount of error. Real Real stands for “computable real”. Spire’s Real implementation is based on ERA, written in Haskell by David Lester. Computable real numbers are those which can be computed (i.e. approximated) to any desired precision. Unlike Double and BigDecimal, Real values are not stored as approximations, but rather as a function from a desired precision to the closest approximate value. If we have an instance x of Real which approximates a real number r, this means that for any precision p (in bits), our instance will produce an x such that x/2^p is the closest rational value to r. Translated into Scala, this means that x.apply(p) returns a SafeLong value x, such that Rational(x, SafeLong(2).pow(p)) is a best approximation for r. Spire represents two types of Real values: Exact and Inexact. The former are rational values for which we have an existing instance of Rational, and are inexpensive to work with. The latter are functions for approximating (potentially) irrational values, are lazily evaluated and memoized, and can potentially be very expensive to compute. As with Rational values, operations on Real values are able to obey the relevant algebraic identities. But unlike Rational, Real supports roots and trigonometric functions. Furthermore, important trig identities are also preserved: import spire.math.Real import Real.{sin, cos} // will return Real(1) no matter what value is provided def circle(a: Real): Real = sqrt(cos(a).pow(2) + sin(a).pow(2)) One interesting consequence of the design of computable real numbers is non-continuous operations (such as sign tests, comparisons, and equality) cannot be performed exactly. If x.apply(p) returns 0, there is no way to know whether the value is actually zero, or just a very small value (either positive or negative!) which is approximately zero at this precision. Similarly, it’s not possible to say that x is equal to y, but only that they are equivalent (or not) at a given precision. Spire currently bakes in a “default” precision to use with these kinds of methods. Furthermore, these methods will always work with Exact values: the issues only arise when using Inexact values. Given that the alternative to using Real is to use another approximate type, providing approximate comparisons and equality seems like a reasonable compromise. Which number types should I use? Spire provides many number types, and it is not always obvious what their relative merits are. This section explains the distinctions between them, and may help you decide which numeric representation(s) to use. There is usually a tension between numbers that have correctness caveats (like possible overflow or precision issues) and numbers that have performance caveats (like extra allocations and/or slower code). Spire provides a wide range of numeric types that should address most needs. Natural numbers (unsigned, whole-value numbers) For non-negative numbers, the safe type to use is Natural. It is quite fast when representing small-ish numbers (128-bits or less), but has no upper bound on the values it can represent. However, its unique cons-structure means that for very large values BigInt and SafeLong may be faster. Since it only supports non-negative values, subtraction is non-total (and may throw an exception). If your values are guaranteed to be small (or you are prepared to detect truncation), you can use UByte (8-bit), UShort (16-bit), UInt (32-bit), or ULong (64-bit), depending on how much space you need. These types have the same unsigned semantics as unsigned types in languages like C. These types are not boxed, although care must be used with arrays (like any value class). Integer numbers (signed, whole-value numbers) There are two safe types that can be used with integer values: SafeLong and BigInt. Both support arbitrarily large values, as well as the usual semantics for things like integer division (quot). The former (SafeLong) performs much better for values that can be represented with a Long (e.g. 64-bit or less), and is a good default choice. When dealing with values that are mostly or entirely very large, BigInt may be a bit faster. Like the unsigned case, you can use Byte (8-bit), Short (16-bit), Int (32-bit), or Long (64-bit) to handle cases where your values are small, or where you want to avoid allocations and will handle truncation issues yourself. These types are provided by Scala (and ultimately the JVM) and will not cause object allocations. Fractional numbers (numbers that can be divided) There are many different fractional flavors, which support various trade-offs between expressive power, precision, and performance. Fractional types come in two basic flavors: precise or imprecise. Imprecise types (like Double) will accumulate error and are not associative in some cases (meaning that (x + y) + z may produce different results than x + (y + z)). These types are often faster than precise types but can be risky to use. Precise numbers make stronger precision guarantees, but at the cost of performance or expressiveness. They are often a bit slower, and may restrict the operations they support (to preserve guarantees about precision). Precise types The most powerful precise type is Real. It represents computable real numbers, and supports all the operations you would expect, including roots and trigonometry. However, irrational values (like Real(2).sqrt or Real.pi) are represented via functions from precision to approximations. This means that in some situations this type might be too slow, or use too much memory. Additionally, operations requiring comparison or equality tests can only be approximately computed. However, this type should never accumulate error, so your results will always be correctly approximated to whatever precision you need. The next precise type is Algebraic. This type supports all rational values as well as roots. However, it cannot represent transcendental values like “pi”, making its values a subset of Real’s. Unlike Real, this type is able to do exact sign tests (and thus, equality tests and comparisons). Due to the ASTs Algebraic uses to represent expressions, execution may be slow and involve lots of allocations. Finally there is Rational. This type represents values as irreducible fractions (e.g. n/d). Rational cannot represent irrational values (such as roots), but efficiently implements all operations on rational values. This type has the fewest performance “gotchas”, although obviously fractions with large numerators or denominators will take longer to operate on. Imprecise types These types are more efficient than the precise types, but require care and analysis to ensure that results are correct and sufficiently accurate. The imprecise type with the most potential precision is BigDecimal which is provided by Scala. This number approximates real values to a number of decimal (base-10) digits (by default 34). Unlike floating point values, this type has an exact representation of values like 0.111110, and the user can use java.math.MathContext to configure how much precision is used. Even so, the type is still subject to accumulated rounding error, and thus is not truly associative. Next come Float and Double, the built-in 32- and 64-bit floating-point implementations on the JVM. The pitfalls of using floating-point values are well-known (and documented elsewhere) but these types are very fast. Finally, Spire supports the experimental FixedPoint class. This value class uses unboxed Long values to represent fractions in terms of user-specified denominator (supplied via an implicit FixedScale instance). This is a very special-purpose type to be used in cases where floating-point approximations have problems and unboxed values are required. You should avoid this type unless your applications has a known, specific need for fixed-point arithmetic. Other types The other numeric and pseudo-numeric types (like Polynomial, Interval, Complex, and Quaternion) each implement specific functionality, so there should be less confusion about which type to use. The sections describing these types explain their properties and trade-offs. Pseudo-Random Number Generators, Distributions, etc Since Spire tries to make number types more pluggable in Scala code, it only makes sense that we’d want to allow users to easily generate a wide variety of number types using pluggable PRNGs. The spire.random package contains random number generators appropriate to many different tasks, as well as a functional interface to creating uniform distributions of values. Pseudo-Random Number Generators This section needs revising! Immutable generators have been replaced by the Random[A] monad, and the package structure has changed a bit! Spire supports two types of PRNGs: mutable and immutable. The mutable.Generator trait represents a PRNG strategy. Using uniformly-generated Int or Long values it can generate random values, arrays of values, and so on. Defining a generator is relatively easy (for a very simple example see Lcg64). By default, generators are not threadsafe. A synchronized generator can be created from an unsynchronized one via the sync method. Generators can be copied, and their seeds can be saved and restored. This allows users to create deterministic streams of values by using the same seed. In general, it is preferred for users to create and use their own generators as opposed to relying on a single generator across threads. Although the mutable.Generator trait itself only provides low-level methods like nextInt, it can produce values of any type using the Dist[A] type class, which will be discussed in the next section. The immutable.Generator trait is similar to mutable.Generator, although the state it stores is immutable. Each time a number is generated a new generator is returned as well, which allows these generators to be used in a pure-functional context. The same Dist[A] instances that would be used with a mutable generator are also applicable here. Creation random values with Dist[A] The Dist[A] type class represents a strategy for generating a distribution of A values given a Generator instance. Dist[A] makes no guarantee as to how the A values are distributed (for instance, it may always return the same value). Users who are interested in particular distributions should use the Uniform[A], Gaussian[A], and Exponential[A] traits to generate Dist[A] instances that correspond to their needs. The Dist[A] objects themselves are immutable and are powered by generators (both mutable and immutable). They can be transformed via map, flatMap, and other combinators. Given the appropriate structure on A, Dist[A] instances can also be operated on as if they were value. Distributions Currently, spire.random provides Uniform[A], Gaussian[A], and Exponential[A] type classes which given appropriate parameters can produce Dist[A] instances. Since most types have a (approximately) infinite number of possible values, bounds and other constraints need to be put on these types before we can usefully talk about (or implement) probability distributions in Spire. Given min and max, a Uniform[A] instance can produce a uniformly-distributed Dist[A] instance. Given mean and stdDev, a Gaussian[A] instance can produce a Dist[A] whose values are distributed according to the desired gaussian distribution. Given rate, a Gaussian[A] instance can produce a Dist[A] whose values are distributed according to the desired exponential distribution."
    } ,    
    {
      "title": "Readme",
      "url": "/spire/",
      "content": "Spire Overview Spire is a numeric library for Scala which is intended to be generic, fast, and precise. Using features such as specialization, macros, type classes, and implicits, Spire works hard to defy conventional wisdom around performance and precision trade-offs. A major goal is to allow developers to write efficient numeric code without having to “bake in” particular numeric representations. In most cases, generic implementations using Spire’s specialized type classes perform identically to corresponding direct implementations. Scaladoc Spire is provided to you as free software under the MIT license. Organization There is a #spire channel on the Typelevel Discord. It is the place to go for announcements and discussions around Spire. We also have a guide on contributing to Spire as well as a guide that provides information on Spire’s design. Spire has maintainers who are responsible for signing-off on and merging pull requests, and for helping to guide the direction of Spire: Erik Osheim (erik@osheim.org) Tom Switzer (thomas.switzer@gmail.com) Rüdiger Klaehn (rklaehn@gmail.com) Denis Rosset (physics@denisrosset.com) Code of Conduct People are expected to follow the Typelevel Code of Conduct when discussing Spire on the Github page, in Discord, Gitter, the IRC channel, mailing list, and other official venues. Concerns or issues can be sent to any of Spire’s maintainers, or to any of the designated CoC contacts for Typelevel. Set up Spire is currently available for Scala 2.13 and 3.1+, for the JVM and JS platforms. To get started with SBT, simply add the following to your build.sbt file: libraryDependencies += \"org.typelevel\" %% \"spire\" % \"0.18.0-M2\" (Previous to 0.14.0, Spire was published under org.spire-math instead of org.typelevel.) For information on all the available versions, visit the Scaladex entry. Here is a list of all of Spire’s modules: spire-macros: macros and compile-time code (required by spire) spire: the core Spire library, the types and type classes spire-laws: optional support for law-checking and testing spire-extras: extra types which are more specific or esoteric Spire depends on typelevel/algebra and uses this project to interoperate with Cats and Algebird. Playing Around The quickest way to try spire is in the browser with Scastie. With Ammonite REPL If you have Ammonite, you can use an interactive REPL session. Welcome to the Ammonite Repl 2.x.x @ import $ivy.`org.typelevel::spire:0.18.0-M2` @ import spire._ @ import spire.math._ @ import sipre.implicits._ @ Complex(3.0,5.0).sin res: Complex[Double] = Complex(real = 10.472508533940392, imag = -73.46062169567367) With an IDE You can also play around with IntelliJ or VS Code and Metals. Create a worksheet file spire.worksheet.sc in your IDE and copy-paste the following code snippet. import $ivy.`org.typelevel::spire:0.18.0-M2` import spire._ import spire.math._ import spire.implicits._ Complex(3.0,5.0).sin res: Complex[Double] = Complex(real = 10.472508533940392, imag = -73.46062169567367) With git and sbt If you clone the Spire repo, you can get a taste of what Spire can do using SBT’s console. Launch sbt and at the prompt, type coreJVM/console: &gt; coreJVM/console [info] Generating spire/std/tuples.scala [info] Starting scala interpreter... [info] Welcome to Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_51). Type in expressions to have them evaluated. Type :help for more information. scala&gt; import spire.implicits._ import spire.implicits._ scala&gt; import spire.math._ import spire.math._ scala&gt; Complex(3.0, 5.0).sin res0: spire.math.Complex[Double] = (10.472508533940392 + -73.46062169567367i) Number Types In addition to supporting all of Scala’s built-in number types, Spire introduces several new ones, all of which can be found in spire.math: Natural unsigned, immutable, arbitrary precision integer Rational fractions of integers with perfect precision Algebraic lazily-computed, arbitrary precision algebraic numbers Real computable real number implementation Complex[A] complex numbers, points on the complex plane Jet[A] N-dimensional dual numbers, for automatic differentiation Quaternion[A] extension of complex numbers into 4D space UByte through ULong value classes supporting unsigned operations SafeLong fast, overflow-proof integer type Number boxed type supporting a traditional numeric tower Interval[A] arithmetic on open, closed, and unbound intervals Polynomial[A] univariate (single-variable) polynomial expressions Trilean value class supporting three-valued logic FixedPoint fractions with Long numerator and implicit denominator (in extras) Detailed treatment of these types can be found in the guide. Type Classes Spire provides type classes to support a wide range of unary and binary operations on numbers. The type classes are specialized, do no boxing, and use implicits to provide convenient infix syntax. The general-purpose type classes can be found in spire.math and consist of: Numeric[A] all number types, makes “best effort” to support operators Fractional[A] fractional number types, where / is true division Integral[A] integral number types, where / is floor division Some of the general-purpose type classes are built in terms of a set of more fundamental type classes defined in spire.algebra. Many of these correspond to concepts from abstract algebra: Eq[A] types that can be compared for equality Order[A] types that can be compared and ordered PartialOrder[A] types that can be compared for equality, and for which certain pairs are ordered Semigroup[A] types with an associative binary operator |+| Monoid[A] semigroups that have an identity element Group[A] monoids that have an inverse operator (Left/Right/)Action[P, G] left/right/ actions of semigroups/monoids/groups Semiring[A] types that form semigroups under + and * Rng[A] types that form a group under + and a semigroup under * Rig[A] types that form monoids under + and * Ring[A] types that form a group under + and a monoid under * EuclideanRing[A] rings with quotients and remainders (euclidean division) Field[A] euclidean rings with multiplicative inverses (reciprocals) Signed[A] types that have a sign (negative, zero, positive) NRoot[A] types that support k-roots, logs, and fractional powers Module[V,R] types that form a left R-module VectorSpace[V,F] types that form a vector space NormedVectorSpace[V,F] types with an associated norm InnerProductSpace[V,F] types with an inner product MetricSpace[V,R] types with an associated metric Trig[A] types that support trigonometric functions Bool[A] types that form a Boolean algebra Heyting[A] types that form a Heyting algebra Variants of Semigroup/Monoid/Group/Action with partial operations are defined in the spire.algebra.partial subpackage. In addition to the type classes themselves, spire.implicits defines many implicits which provide unary and infix operators for the type classes. The easiest way to use these is via a wildcard import of spire.implicits._. Detailed treatment of these type classes can be found in the guide. Getting Started Spire contains a lot of types, as well as other machinery to provide a nice user experience. The easiest way to use spire is via wildcard imports: import spire.algebra._ // provides algebraic type classes import spire.math._ // provides functions, types, and type classes import spire.implicits._ // provides infix operators, instances and conversions Of course, you can still productively use Spire without wildcard imports, but it may require a bit more work to figure out which functionality you want and where it’s coming from. Operators by Type Class The following is an outline in more detail of the type classes provided by Spire, as well as the operators that they use. While Spire avoids introducing novel operators when possible, in a few cases it was unavoidable. Eq, Order and PartialOrder The type classes provide type-safe equivalence and comparison functions. Orderings can be total (Order) or partial (PartialOrder); although undefined elements like NaN or null will cause problems in the default implementations [1]. Eq eqv (===): equivalence neqv (=!=): non-equivalence Order compare: less-than (-1), equivalent (0), or greater-than (1) gt (&gt;): greater-than gteqv (&gt;=): greater-than-or-equivalent lt (&lt;): less-than lteqv (&lt;=): less-than-or-equivalent min: find least value max: find greatest value PartialOrder partialCompare: less-than (-1.0), equivalent (0.0), greater-than (1.0) or incomparable (NaN) tryCompare: less-than (Some(-1)), equivalent (Some(0)), greater-than (Some(1)) or incomparable (None) pmin: find the least value if the elements are comparable; returns an Option pmax: find the greated value if the elements are comparable; returns an Option gt (&gt;), gteqv (&gt;=), lt (&lt;) and lteqv (&lt;=) return false if the elements are incomparable, or the result of their comparison [1] For floating-point numbers, alternate implementations that take NaN into account can be imported from spire.optional.totalfloat._. Semigroup, Monoid, and Group These general type classes constitute very general operations. The operations range from addition and multiplication to concatenating strings or lists, and beyond! Semigroup op (|+|): associative binary operator Monoid id: an identity element isId: checks (together with Eq) for identity Group inverse: an unary operator There are Additive and Multiplicative refinements of these general type classes, which are used in the Ring-family of type classes. Rings &amp;co The Ring family of type classes provides the typical arithmetic operations most users will expect. Semiring plus (+): addition times (*): multiplication pow (**): exponentiation (integral exponent) Rng negate (-): additive inverse minus (-): subtraction zero: additive identity Rig zero: additive identity one: multiplicative identity Ring (Rng + Rig) GCDRing gcd: greatest-common-divisor lcm: least-common-multiple EuclideanRing quot (/~): quotient (Euclidean division) mod (%): remainder quotmod (/%): quotient and mod Field reciprocal: multiplicative inverse div (/): division ceil: round up floor: round down round: round to nearest NRoot nroot: k-roots (k: Int) sqrt: square root log: natural logarithm fpow (**): exponentiation (fractional exponent) VectorSpaces &amp;co The vector space family of type classes provide basic vector operations. They are parameterized on 2 types: the vector type and the scalar type. Module plus (+): vector addition minus (-): vector subtraction timesl (*:): scalar multiplication VectorSpace divr (:/): scalar division NormedVectorSpace norm: vector norm normalize: normalizes vector (so norm is 1) InnerProductSpace dot (⋅, dot): vector inner product Numeric, Integral, and Fractional These high-level type classes will pull in all of the relevant algebraic type classes. Users who aren’t concerned with algebraic properties directly, or who wish for more permissiveness, should prefer these type classes. Integral: whole number types (e.g. Int, BigInt) Fractional: fractional/decimal types (e.g. Double, Rational) Numeric: any number type, making “best effort” to support ops The Numeric type class is unique in that it provides the same functionality as Fractional for all number types. Each type will attempt to “do the right thing” as far as possible, and throw errors otherwise. Users who are leery of this behavior are encouraged to use more precise type classes. Bool Bool supports Boolean algebras, an abstraction of the familiar bitwise boolean operators. Bool complement (unary ~): logical negation and (&amp;): conjunction or (|): disjunction xor (^): exclusive-disjunction imp: implicitation, equivalent to ~a | b nand: “not-and,” equivalent to ~(a &amp; b) nor: “not-or,” equivalent to ~(a | b) nxor: “not-xor,” equivalent to ~(a ^ b) Bool instances exist not just for Boolean, but also for Byte, Short, Int, Long, UByte, UShort, UInt, and ULong. Trig Trig provides an abstraction for any type which defines trigonometric functions. To do this, types should be able to reasonably approximate real values. Trig e: Euler’s number, 2.71828... pi: Ratio of circle’s circumference to diameter, 3.14159... exp: exponential function, e^x expm1: e^x - 1 log: natural logarithm log1p: log(x + 1) sin, cos, tan: sine, cosine, and tangent, the standard functions of angles asin, acos, atan, atan2: inverse functions sinh, cosh, tanh: hyperbolic functions toRadians, toDegrees: convert between angle units Syntax Using string interpolation and macros, Spire provides convenient syntax for number types. These macros are evaluated at compile-time, and any errors they encounter will occur at compile-time. For example: object LiteralsDemo { import spire.syntax.literals._ // bytes and shorts val x = b\"100\" // without type annotation! val y = h\"999\" val mask = b\"255\" // unsigned constant converted to signed (-1) // rationals val n1 = r\"1/3\" val n2 = r\"1599/115866\" // simplified at compile-time to 13/942 } object RadixDemo { // support different radix literals import spire.syntax.literals.radix._ // representations of the number 23 val a = x2\"10111\" // binary val b = x8\"27\" // octal val c = x16\"17\" // hex } object SIDemo { // SI notation for large numbers import spire.syntax.literals.si._ // .us and .eu also available val w = i\"1 944 234 123\" // Int val x = j\"89 234 614 123 234 772\" // Long val y = big\"123 234 435 456 567 678 234 123 112 234 345\" // BigInt val z = dec\"1 234 456 789.123456789098765\" // BigDecimal } Spire also provides a loop macro called fastFor (previously known as cfor) whose syntax bears a slight resemblance to a traditional for-loop from C or Java. This macro expands to a tail-recursive function, which will inline literal function arguments. The macro can be nested in itself and compares favorably with other looping constructs in Scala such as for and while: import spire.syntax.fastFor._ // print numbers 1 through 10 fastFor(0)(_ &lt; 10, _ + 1) { i =&gt; println(i) } // naive sorting algorithm def selectionSort(ns: Array[Int]) = { val limit = ns.length -1 fastFor(0)(_ &lt; limit, _ + 1) { i =&gt; var k = i val n = ns(i) fastFor(i + 1)(_ &lt;= limit, _ + 1) { j =&gt; if (ns(j) &lt; ns(k)) k = j } ns(i) = ns(k) ns(k) = n } } Sorting, Selection, and Searching Since Spire provides a specialized ordering type class, it makes sense that it also provides its own methods for doing operations based on order. These methods are defined on arrays and occur in-place, mutating the array. Other collections can take advantage of sorting by converting to an array, sorting, and converting back (which is what the Scala collections framework already does in most cases). Thus, Spire supports both mutable arrays and immutable collections. Sorting methods can be found in the spire.math.Sorting object. They are: quickSort fastest, nlog(n), not stable with potential n^2 worst-case mergeSort also fast, nlog(n), stable but allocates extra temporary space insertionSort n^2 but stable and fast for small arrays sort alias for quickSort Both mergeSort and quickSort delegate to insertionSort when dealing with arrays (or slices) below a certain length. So, it would be more accurate to describe them as hybrid sorts. Selection methods can be found in an analogous spire.math.Selection object. Given an array and an index k these methods put the kth largest element at position k, ensuring that all preceding elements are less-than or equal-to, and all succeeding elements are greater-than or equal-to, the kth element. There are two methods defined: quickSelect usually faster, not stable, potentially bad worst-case linearSelect usually slower, but with guaranteed linear complexity select alias for quickSelect Searching methods are located in the spire.math.Searching object. Given a sorted array (or indexed sequence), these methods will locate the index of the desired element (or return -1 if it is not found). search(array, item) finds the index of item in array search(array, item, lower, upper) only searches between lower and upper. Searching also supports a more esoteric method: minimalElements. This method returns the minimal elements of a partially-ordered set. Pseudo-Random Number Generators Spire comes with many different PRNG implementations, which extends the spire.random.Generator interface. Generators are mutable RNGs that support basic operations like nextInt. Unlike Java, generators are not threadsafe by default; synchronous instances can be attained by calling the .sync method. Spire supports generating random instances of arbitrary types using the spire.random.Dist[A] type class. These instances represent a strategy for getting random values using a Generator instance. For instance: object DistDemo { import spire.random.Dist val rng = spire.random.rng.Cmwc5() // produces a map with ~10-20 entries implicit val nextmap: Dist[Map[Int, Complex[Double]]] = Dist.map[Int, Complex[Double]](10, 20) val m = rng.next[Map[Int, Complex[Double]]] // produces a double in [0.0, 1.0) val n = rng.next[Double] // produces a complex number, with real and imaginary parts in [0.0, 1.0) val q = rng.next[Complex[Double]] } Unlike generators, Dist[A] instances are immutable and composable, supporting operations like map, flatMap, and filter. Many default instances are provided, and it’s easy to create custom instances for user-defined types. Miscellany In addition, Spire provides many other methods which are “missing” from java.Math (and scala.math), such as: log(BigDecimal): BigDecimal exp(BigDecimal): BigDecimal pow(BigDecimal): BigDecimal pow(Long): Long gcd(Long, Long): Long and so on… Benchmarks In addition to unit tests, Spire comes with a relatively fleshed-out set of JMH micro-benchmarks. To run the benchmarks from within SBT, change to the benchmark subproject and then jmh:run -l to see a list of benchmarks: $ sbt &gt; project benchmark &gt; jmh:run -l [info] Benchmarks: [info] spire.benchmark.AddBenchmarks.addComplexDoubleStateDirect [info] spire.benchmark.AddBenchmarks.addComplexDoubleStateGeneric [info] spire.benchmark.AddBenchmarks.addComplexFloatStateDirect ... To run all available benchmarks: &gt; jmh:run To run a specific benchmark method: &gt; jmh:run spire.benchmark.AddBenchmarks.addComplexDoubleStateDirect To run all benchmarks in a specific class: &gt; jmh:run spire.benchmark.AddBenchmarks To see all available JMH usage options: &gt; jmh:run -h If you plan to contribute to Spire, please make sure to run the relevant benchmarks to be sure that your changes don’t impact performance. Benchmarks usually include comparisons against equivalent Scala or Java classes to try to measure relative as well as absolute performance. Caveats Code is offered as-is, with no implied warranty of any kind. Comments, criticisms, and/or praise are welcome, especially from numerical analysts! ;) Copyright 2011-2017 Erik Osheim, Tom Switzer A full list of contributors can be found in AUTHORS.md. The MIT software license is attached in the COPYING file."
    } ,        
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
